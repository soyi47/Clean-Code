# 2. 의미 있는 이름

- 이름을 사용하지 않는 곳은 없다. 이름을 잘 지으면 여러모로 편하다. 이름을 잘 짓는 간단한 규칙을 알아본다.

<br />

### 의도를 분명히 밝혀라

- 좋은 이름을 지으려면 시간이 걸리지만 좋은 이름으로 절약하는 시간이 훨씬 더 많다.

- 변수나 함수 그리고 클래스 **이름은 다음과 같은 굵직한 질문에 모두 답해야 한다.** 따로 **주석이 필요하다면 의도를 분명히 드러내지 못했다**는 말이다.

  > 1. 변수(혹은 함수나 클래스)의 존재 이유는?
  > 2. 수행 기능은?
  > 3. 사용 방법은?

- **의도가 드러나는 이름을 사용하면 코드 이해와 변경이 쉬워진다. 코드가 하는 일을 짐작할 수 있게 된다. 좋은 이름을 통해 코드 맥락을 코드 자체에 명시적으로 드러낼 수 있다.** 의도가 드러나는 이름은 '정보 제공'의 역할을 한다. 클래스로 만들거나 명시적인 함수로 식과 변수를 감추면서 좋은 이름을 붙이기만 해도, 코드가 하는 일을 이해하기 쉬워진다.

<br />

### 그릇된 정보를 피하라

- 프로그래머는 코드에 **그릇된 단서를 남겨서는 안 된다. 그릇된 단서는 코드 의미를 흐린다.**

- **널리 쓰이는 의미가 있는 단어를 다른 의미로 사용해서는 안 된다.** 프로그래머에게 **특수한 의미의 단어를 사용할 때는 주의**한다.
  - hp, aix, sco는 유닉스 플랫폼이나 유닉스 변종을 가리키는 이름이므로 변수 이름으로 적합하지 않다. List라는 단어는 프로그래머에게 특수한 의미다. 실제 컨테이너가 List가 아님에도 xxxList로 명명해서는 안 된다.
- 서로 **흡사한 이름을 사용하지 않도록** 주의한다.

- 유사한 개념은 유사한 표기법을 사용한다. 이를 통해 정보를 제공한다. **일관성 있는 표기법으로 제대로 된 정보를 제공**한다.

- 그릇된 단서의 끔찍한 예 중 하나는 소문자 L이나 대문자 O 변수다. 소문자 L은 숫자 1, 대문자 O는 숫자 0처럼 보인다.

<br />

### 의미 있게 구분하라

- 동일한 범위 안에서 다른 두 개념에 같은 이름을 사용하지 못한다고 해서, **연속된 숫자를 덧붙이거나 불용어를 추가하는 방식은 적절하지 못하다. 이름이 달라야 한다면 의미도 달라져야 한다.**

  - **연속적인 숫자를 덧붙인 이름 (a1, a2, ... aN)은 의도적인 이름과 정반대**다. 이는 **아무런 정보를 제공하지 못하는, 저자의 의도가 전혀 드러나지 않는 이름**이다.

  - **불용어를 추가한 이름 역시 아무런 정보도 제공하지 못한다.**

    - Product라는 클래스가 있을 때, 다른 클래스를 ProductInfo 혹은 ProductData라 부른다면, 개념을 구분하지 않을 채 이름만 달리한 것이다. Info나 Data는 의미가 불분명한 불용어다.

    - **이미 사용하려면 변수가 있다는 이유만으로, a, the와 같은 접두어를 사용하여 이름을 지어서는 안 된다.**

    - **불용어는 중복이다.** Name과 NameString, Customer와 Customer Object, Account와 Accounts와 AccountInfo. 이와 같은 이름을 사용한다면, **"그릇된 정보를 피하라"는 규칙의 위반**이다. 동시에 **프로젝트에 참여한 프로그래머는 필요할 때 어느 것을 사용할지 알 수 없다.**

- moneyAcount와 money, customerInfo와 customer, accountData와 account, theMessage와 message. 모두 구분이 안 된다. **읽는 사람이 차이를 알도록 이름을 지어라.**

<br />

### 발음하기 쉬운 이름을 사용하라

- **말을 처리하려고 발달한 두뇌**를 활용하지 않는다면 안타까운 손해다. 그러므로 **발음하기 쉬운 이름을 선택**한다.

- 발음하기 어려운 이름은 토론하기도 어렵다. **발음하기 쉬운 이름을 통해 지적인 대화가 가능해진다.** 아래 예제를 비교해보자.

  ```
  class DtaRcrd102 {
  	private Date genymdhms;
  	private Date modymdhms;
  	private final String pszqint = "102";
  }
  
  class Customer {
  	private Date generationTimeStamp;
  	private Date modificationTimeStamp;
  	private final String recordID = "102";
  }
  ```

<br />

### 검색하기 쉬운 이름을 사용하라

- 문자 하나를 사용하는 이름과 상수는 텍스트 코드에서 쉽게 눈에 띄지 않는다. 변수나 상수를 코드 여러 곳에서 사용한다면 검색하기 쉬운 이름이 바람직하다. **검색하기 쉬운 이름이 상수보다 좋다.**
  - MAX_CLASSES_PER_STUDENT는 grep으로 찾기가 쉽지만, 숫자 7은 찾기 까다롭다. 7이 들어가는 모든 파일 이름과 수식이 검색되고, 사용한 의도가 다른 경우까지 나온다. 7이 들어가는 이름을 모두 찾은 후 의미를 분석해 원하는 상수를 가려내야 한다. 상수에 버그가 있어도 검색으로 찾지 못하게 된다.
- **이름의 길이는 범위 크기에 비례해야 한다.** **범위가 작으면 아주 짧은 이름을 사용해도 괜찮다.** 간단한 메서드에서 로컬 변수만 한 문자를 사용한다. 범위가 5줄 안팎이라면 i, j 같은 변수 이름도 괜찮다. 반면, **이름이 짧은 변수가 함수는 범위가 길어지면 의미를 잃는다.** 그러므로 **이름을 사용하는 범위가 길수록 이름을 정확하고 길게 짓는다.**

<br />

### 인코딩을 피하라

- **이름에 유형 정보나 범위 정보를 넣어서는 안 된다.** 중복된 정보이며 독자만 혼란하게 만든다. 부담을 더하지 않아도 이름에 인코딩할 정보는 아주 많다. 유형이나 범위 정보까지 인코딩에 넣으면 그만큼 이름을 해독하기 어려워진다.
- **헝가리식 표기법**
  - 헝가리식 표기법은 **데이터 타입을 이름에 명시하는 방식**이다. 과거 윈도 C API의 모든 변수는 속성과 용도가 다른, 여러 '문자열' 중 하나였고, 컴파일러가 타입을 점검하지 않아 프로그래머에게 타입을 기억할 단서가 필요했다.
  - 이제는 헝가리식 표기법이나 기타 인코딩 방식이 오히려 방해가 될 뿐이다. **변수, 함수, 클래스 이름이나 타입을 바꾸기가 어려워지며, 읽기도 어려워진다.** 독자를 오도할 가능성도 커진다.
- **멤버 변수 접두어**
  - 이제는 멤버 변수에 m\_이라는 접두어를 붙일 필요도 없다. **클래스와 함수는 접두어가 필요없을 정도로 작아야 마땅**하다. 또 멤버 변수를 다른 색상으로 표시하거나 **눈에 띄게 보여주는 IDE를 사용**해야 마땅하다.

+ **인터페이스와 구현 클래스**

  + 때로는 인코딩이 필요한 경우도 있다. 예를 들어 도형을 생성하는 ABSTRACT FACTORY를 구현하는데, **인터페이스 클래스(interface class)가 있고, 구현은 구체 클래스(concrete class)에서 한다고 가정하자.** 이름은 어떻게 지을까? IShapeFactory와 ShapeFactory?

    옛날 코드에서 많이 사용하는 접두어 I는 주의를 흐트리고 과도한 정보를 제공하기도 한다. **이 클래스가 인터페이스라는 사실을 꼭 알려야 할까? 클래스 사용자는 그냥 ShapeFactory라고만 생각하면 좋겠다.** 그래서 두 클래스 이름 중 하나를 **인코딩해야 한다면 구현 클래스 이름을 택하겠다.** ShapeFactoryImp나 CShapeFactory가 IShapeFactory보다 좋다.

<br />

