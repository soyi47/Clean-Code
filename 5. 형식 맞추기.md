# 5. 형식 맞추기

+ 뚜껑을 열었을 때 독자들이 **코드가 깔끔하고, 일관적이며, 꼼꼼하다고 감탄하면 좋겠다. 질서 정연하다고 탄복하면 좋겠다.** 

  **프로그래머라면 형식을 깔끔하게 맞춰 코드를 짜야 한다**. 코드 형식을 맞추기 위한 간단한 규칙을 정하고 그 규칙을 착실히 따라야 한다. 팀으로 일한다면 팀이 합의해 규칙을 정하고 모두가 따라야 한다. 필요하다면 규칙을 자동으로 적용하는 도구를 활용한다.

<br />

### 형식을 맞추는 목적

+ **코드 형식은 중요하다!** 너무나도 중요하므로 융통성 없이 맹목적으로 따르면 안 된다. **코드 형식은 의사소통의 일환이다. 의사소통은 전문 개발자의 일차적인 의무다.**
+ 오늘 구현한 기능은 다음 버전에서 바뀔 확률이 아주 높다. 그런데 **오늘 구현한 코드의 가독성은 앞으로 바뀔 코드의 품질에 지대한 영향을 미친다**. 더 이상 원래 코드의 흔적을 찾아보기 어려울 정도로 바뀌어도, 맨 처음 잡아놓은 구현 스타일과 가독성 수준은 유지보수 용이성과 확장성에 계속 영향을 미친다. **코드는 사라질지라도 개발자의 스타일과 규율은 사리지지 않는다.**

<br />

### 적절한 행 길이를 유지하라

- 클래스 크기는 따로 다루고 여기서는 파일 크기, 파일의 세로 길이를 고려한다.
- JUnit, FitNesse, testNG, Time and Money(tam), JDepend, Ant, Tomcat 프로젝트의 파일 길이를 조사한 결과를 통해, **500줄을 넘지 않고 대부분 200줄 정도인 파일로도 커다란 시스템을 구축할 수 있다**는 사실을 알 수 있다. 이는 반드시 지킬 엄격한 규칙은 아니지만 바람직한 규칙으로 삼으면 좋겠다. 일반적으로 큰 파일보다 작은 파일이 이해하기 쉽다.

#### 신문 기사처럼 작성하라

- 아주 좋은 신문 기사를 떠올려보라. 독자는 위에서 아래로 읽는다. 최상단에 기사를 몇 마디로 요약하는 표제가 있고, 독자를 이 표제를 보고 기사를 읽을지 말지 결정한다. 첫 문단은 전체 내용을 요약하며 커다란 그림을 보여준다. 쭉 읽으며 내려가면 세세한 내용들이 드러난다.
- 소스 파일은 신문 기사와 비슷하게 작성한다. 
  - 이름만 보고도 올바른 모듈을 살펴보고 있는지 아닌지 판단할 수 있을 정도로 **설명이 가능하면서 간단한 이름**을 짓는다. **마치 신문기사의 표제처럼** 말이다. 소스의 **아래로 내려갈수록 의도를 세세하게 묘사**한다. 소스 파일 첫 부분은 고차원 개념과 알고리즘을 설명한다. 마지막에는 가장 저차원 함수와 세부 내역이 나온다. 
  - 신문은 다양한 기사로 이루어진다. 대다수 기사가 아주 짧고 어떤 기사는 조금 길다. 무작위로 뒤 섞은 긴 기사 하나만 있다면 아무도 읽지 않는다. 소스 또한 적절히 나누어야 한다.

#### 개념은 빈 행으로 분리하라

- 각 행은 수식이나 절을 나타내고, 일련의 행 묶음은 완결된 생각 하나를 표현한다. **생각 사이는 빈 행을 넣어 분리해야 마땅하다. 빈 행은 새로운 개념을 시작한다는 시각적 단서다.** 단지 줄바꿈 차이로, 행 묶음이 분리되어 보이거나 반대로 전체가 한 덩어리로 보일 수 있다.

#### 세로 밀집도

- 줄바꿈이 개념을 분리한다면 세로 밀집도는 연관성을 의미한다. **서로 밀접한  코드 행은 세로로 가까이 놓여야 한다**는 뜻이다. 

#### 수직 거리

- 시스템의 동작을 이해하고 싶은데, 코드 조각들이 어디에 있는지 찾고 기억하느라 시간과 노력을 소모하게 된다. **서로 밀접한 개념은 세로로 가까이 둬야 한다.** 또 타당한 근거가 없다면 서로 밀접한 개념은 한 파일에 속해야 마땅하다. 같은 파일에 속할 정도의 밀접한 두 개념은 세로 거리로 연관성을 표현한다. **연관성은 한 개념을 이해하는 데 다른 개념이 중요한 정도다. 연관성이 깊은 두 개념은 서로 가까이 있어야 한다.**
  - **변수 선언**. 변수는 **사용하는 위치에 최대한 가까이** 선언한다.
  - **인스턴스 변수**. 인스턴스 변수는 **클래스의 잘 알려진 위치(클래스 맨 처음, 혹은 클래스 마지막)에 모아둔다.** 변수 간에 세로로 거리를 두지 않는다. 잘 설계한 클래스는 **대다수의 메서드가 인스턴스 변수를 사용**한다.
  - **종속 함수**. 한 함수가 다른 함수를 호출한다면 **두 함수는 세로로 가까이 배치**한다. 또 **호출하는 함수를 호출되는 함수보다 먼저 배치**한다. 호출 순서로 정의하면 호출되는 함수를 찾기가 쉬워지고, 프로그램이 자연스럽게 읽히면서 **가독성이 높아진다.**
  - **개념적 유사성**. 개념적인 친화도가 높을수록 코드를 가까이 배치한다. 친화도는  한 함수가 다른 함수를 호출하면서 생기는 직접적인 종속성으로 생기기도 한다. 또 변수와 그 변수를 사용하는 함수의 관계에서도 높은 친화도를 확인할 수 있다. 다르게 비슷한 동작을 수행하는, 명명법이 같고 기본 기능이 유사한 함수들도 개념적으로 친화도가 높아 가까이 배치해야 한다.

#### 세로 순서

- **함수 호출 종족성은 아래 방향으로 유지한다. 호출되는 함수를 호출 하는 함수보다 나중에 배치한다.** 그러면 소스 코드 모듈은 **자연스럽게 고차원에서 저차원으로 내려간다.** 가장 중요한 개념을 가장 먼저 표현한다. 이때 세세한 사항을 최대한 배제하고, 그 세세한 사항은 마지막에 표현한다. 그러면 **독자는 세세한 사항까지 파고들 필요 없이, 첫 함수 몇 개만 읽어도 개념을 파악하기 쉬워진다.**

<br />

### 가로 형식 맞추기

- 짧은 행이 바람직하다. 옛날 홀러리스(Hollerith)가 내놓은 80자 제한은 다소 인위적이다. 100자 120자에 달해도 나쁘지 않다. 하지만 그 이상은 솔직히 주의부족이다. 요즘은 모니터가 아주 커서 200자까지도 한 화면에 들어갈 수 있지만, 가급적 그렇게 하지 말고 **120자 정도로 행 길이를 제한하기를 권한다.**

#### 가로 공백과 밀집도

- 가로 공백을 사용해 밀접한 개념과 느슨한 개념을 표현한다.
  - 할당문은 왼쪽 요소와 오른쪽 요소가 분명히 나뉜다. 이를 강조하기 위해 앞뒤에 공백을 준다. ex) `int lineSize = line.length()`;
  - 함수와 인수를 서로 밀접하기 때문에, 함수 이름과 괄호 사이에는 공백을 넣지 않는다. ex) `recordWidestLine(lineSize);`
  - 연산자 우선순위를 강조하기 위해 공백을 사용한다. (하지만 코드 형식을 자동으로 맞춰주는 도구 대다수는 연산자 우선 순위를 고려하지 않아, 나중에 도구에서 없애는 경우가 흔하다.) ex) `b*b - 4*b*c`

#### 가로 정렬

- 선언문과 할당문을 별도로 정렬하는 것은 오히려 유용하지 못하다. **코드가 엉뚱한 부분을 강조하여 의도가 가려지는 정렬은 지양해야 한다.** 그러한 정렬은 하지 않을 때 오히려 오히려 중대한 결함을 찾기 쉽다. 만약 정렬이 필요할 정도로 목록이 길다면, 문제는 목록의 길이지 정렬 부족이 아니다. 만약 선언부가 너무 길다면 클래스를 쪼개야 한다.

#### 들여쓰기

- 범위로 이루어진 계층을 표현하기 위해 코드를 들여쓴다. **들여쓰는 정도는 계층에서 코드가 자리잡은 수준에 비례한다.** 클래스처럼 파일 수준인 문장은 들여쓰지 않는다. 클래스 내 메서드는 클래스보다 한 수준 들여쓴다. 또 메서드 코드는 메서드 선언보다 한 수준 들여쓴다. 블록 코드는 블록을 포함하는 코드보다 한 수준 들여쓴다. 이렇게 **왼쪽으로 코드를 맞춰 코드가 속하는 범위를 시각적으로 표현한다.**

- 때로는 간단하고 짧은 if문, while문 등에서 들여쓰기 규칙을 무시하고픈 유혹이 생긴다. 그런 때마다 원점으로 돌아가 들여쓰기를 넣는다. 한 행에 범위를 뭉뚱그린 코드는 피한다.

#### 가짜 범위

- 때로는 빈 while 문이나 for 문을 접한다. 이런 구조는 가능한 피하려 하지만 피하지 못할 때는 빈블록을 올바로 들여쓰고 괄호로 감싼다.
- while문 끝에 세미콜론(;) 하나가 살짝 덧붙으면 골탕 먹기가 쉽다. 세미콜론(;)은 새 행에다 제대로 들여써서 넣어주어 눈에 띄도록 만든다.

### 팀 규칙

- 각자 선호하는 규칙이 있겠지만, 팀에 속한다면 자신이 선호해야 할 규칙은 팀 규칙이다. 팀은 한 가지 규칙에 합의해야 하고, 모든 팀원은 그 규칙을 따라야 한다. 그래야 소프트웨어가 일관적인 스타일을 가질 수 있다. 팀이 정한 규칙이 내가 선호하는 규칙은 아닐지라도, 팀 규칙에 따라 코드를 구현해야 한다.
- 좋은 소프트웨어 시스템은 읽기 쉬운 문서로 이루어 진다. 이를 위해서 스타일은 일관적이고 매끄러워야 한다. 한 소스 파일의 형식은 다른 소스파일에도 쓰이리라는 신뢰감을 독자에게 주어야 한다.
